#include "powerpylon.h"



int static _unit_neighbours(const int radius) {
	/* This will waste a lot of memory, but I just want to get this shit to work */
	return (radius*2+1)*(radius*2+1);
}



int _unit_pylon_list_remove(struct PylonEntry *from, struct PylonEntry *del) {
	int i;

	for (i = 0; i < from->neighbours; i++) {
		if (from->neighbour[i] == del) {
			from->neighbour[i] = NULL;
			return 0;
		}
	}

	return -1;
}


static void _unit_pylon_list_add(


static void _unit_pylon_pulse_climb(struct PylonEntry *pylon) {
	int i;
	
	if (pylon->pulse)
		return;
	pylon->pulse = 1;
	
	for (i = 0; i < pylon->neighbours; i++)
		if (pylon->neighbour[i])
			_unit_pylon_pulse_climb(pylon->neighbour[i]);

	return;
}


static void _unit_pylon_pulse() {
	int i;
	struct PylonEntry *list;

	for (i = 0; i < server->players; i++) {
		if (server->player[i].status != PLAYER_IN_GAME_NOW)
			continue;
		if (!server->map[server->player[i].spawn.index])
			return;
		if (server->map[server->player[i].spawn.index]->type != UNIT_DEF_GENERATOR)
			continue;
		_unit_pulon_pluse_climb(&server->map[server->player[i].spawn.index]->pylon);
	}

	list = server->pylons;
	
	while (list != NULL) {
		if (list->pulse) {
			if (list->power);
			else {
				list->power = 1;
				//playerCalcSetPower(list->unit->owner, list->x, list->y, 1);
			}
		} else {
			if (list->power) {
				list->power = 0;
				//playerCalcSetPower(list->unit->owner, list->x, list->y, -1);
			}
		}
		list->pulse = 0;

		list = list->next;
	}

	return;
}


void _unit_pylon_delete(struct unit *unit) {
	struct PylonEntry **list;
	int i;

	if (unit->pylon.power)
		playerCalcSetPower(unit->owner, unit->pylon.x, unit->pylon.y, -1);
	
	for (i = 0; i < unit->pylon.neighbours; i++)
		if (unit->pylon.neighbour[i])
			unitPylonListRemove(unit->pylon.neighbour[i], &unit->pylon);
	free(unit->pylon.neighbour);
	unit->pylon.neighbour = NULL;

	list = &server->pylons;

	if (server->pylons == NULL)
		return;

	while (*list) {
		if ((*list)->unit == unit) {
			*list = (*list)->next;
			return;
		}

		list = &(*list)->next;
	}

	return;
}


void pylon_init(SERVER_UNIT *unit, unsigned int x, unsigned int y) {
	int i, j, k, owner, team, radius, index;

	owner = unit->owner;
	team = server->player[owner].team;
	radius = unitRange(unit->type);

	unit->pylon.x = x;
	unit->pylon.y = y;
	unit->pylon.pulse = 0;
	unit->pylon.power = 0;
	unit->pylon.unit = unit;
	unit->pylon.neighbours = _unit_neighbours(PYLON_RANGE);
	unit->pylon.neighbour = malloc(sizeof(*unit->pylon.neighbour) * unit->pylon.neighbours);

	for (i = 0; i < unit->pylon.neighbours; i++)
		unit->pylon.neighbour[i] = NULL;

	for (j = -1 * radius; j <= radius; j++) {
		if (j + x < 0 || j + x >= server->w)
			continue;
		for (k = -1 * radius; k <= radius; k++) {
			if (k + y < 0 || k + y >= server->h)
				continue;
			if (k * k + j * j > radius*radius)
				continue;
			index = (y + k) * server->w + (x + j);
			if (!server->map[index])		/* No building here - don't bother */
				continue;
			if (server->map[index]->type != UNIT_DEF_GENERATOR && server->map[index]->type != UNIT_DEF_PYLON)
				/* Wrong type of building. We have no business to do here */
				continue;
			if (team > -1) {
				if (server->player[server->map[index]->owner].team != team)
					/* Building is not on our team */
					continue;
			} else if (server->map[index]->owner != owner)	/* We don't own it */
				continue;
			if (server->map[index]->pylon.power && !unit->pylon.power) {
				playerCalcSetPower(owner, x, y, 1);
				unit->pylon.power = 1;
			}

			unitPylonListAdd(&server->map[index]->pylon, &unit->pylon);
			unitPylonListAdd(&unit->pylon, &server->map[index]->pylon);
		}
	}
	
	unit->pylon.power = (unit->type == UNIT_DEF_GENERATOR) ? 1 : unit->pylon.power;
	unit->pylon.next = server->pylons;
	server->pylons = &unit->pylon;

	unitPylonPulse();

	return;
}
